<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 1000vh;
        font-family: "Inter", sans-serif;
        background: #000;
        color: #fff;
      }

      p {
        font-size: 13px;
        font-weight: 400;
        line-height: 1.5;
        opacity: 0.5;
      }

      p#logo {
        opacity: 1;
      }

      nav {
        position: fixed;
        top: 0;
        width: 100vw;
        padding: 2em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 2;
      }

      .nav-links {
        display: flex;
        gap: 2em;
      }

      footer {
        position: fixed;
        bottom: 0;
        width: 100vw;
        padding: 2em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 2;
      }

      .slider-wrapper {
        position: fixed;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgb(0, 0, 0);
        background: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 75%,
          rgba(0, 0, 0, 0.5) 100%
        );
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <nav>
      <div class="site-info">
        <p id="logo">Social Moodboard</p>
        <p>We don't do Ordinary here</span></p>
      </div>
      <div class="nav-links">
        <button>Back</button >
  
      </div>
    </nav>

   

    <div class="slider-wrapper">
      <canvas></canvas>
    </div>

    <div class="overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/studio-freight/lenis@1.0.27/bundled/lenis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script>
      window.addEventListener("load", () => {
        // Define slide titles for your 12 images
       
        const lenis = new Lenis();
        function raf(time) {
          lenis.raf(time);
          requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        const images = [];
        let loadedImageCount = 0;
        const totalSlides = 12; // Updated to use all 12 images

        function loadImages() {
          for (let i = 1; i <= totalSlides; i++) {
            const img = new Image();
            img.onload = function () {
              images.push(img);
              loadedImageCount++;

              if (loadedImageCount === totalSlides) {
                initializeScene();
              }
            };
            img.onerror = function () {
              console.error(`Failed to load image: img${i}.jpg`);
              loadedImageCount++;
              if (loadedImageCount === totalSlides) {
                initializeScene();
              }
            };
            img.src = `./img${i}.jpg`;
          }
        }

        function initializeScene() {
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.9,
            1000
          );

          const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("canvas"),
            antialias: true,
            powerPreference: "high-performance",
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setClearColor(0x000000);

          // INCREASED DIMENSIONS: Significantly larger parent plane for bigger photos
          const parentWidth = 50;  // Increased from 35
          const parentHeight = 110; // Increased from 85
          const curvature = 35;
          const segmentsX = 200;
          const segmentsY = 200;

          const parentGeometry = new THREE.PlaneGeometry(
            parentWidth,
            parentHeight,
            segmentsX,
            segmentsY
          );

          const positions = parentGeometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            const y = positions[i + 1];
            const distanceFromCenter = Math.abs(y / (parentHeight / 2));
            positions[i + 2] = Math.pow(distanceFromCenter, 2) * curvature;
          }
          parentGeometry.computeVertexNormals();

          // INCREASED SLIDE SIZE: Much larger individual slides
          const slideHeight = 45; // Increased from 25 for significantly larger images
          const gap = 0.5; // Reduced gap to allow larger images
          const cycleHeight = totalSlides * (slideHeight + gap);

          // INCREASED TEXTURE DIMENSIONS: Higher resolution canvas for sharper images
          const textureCanvas = document.createElement("canvas");
          const ctx = textureCanvas.getContext("2d", {
            alpha: false,
            willReadFrequently: false,
          });
          textureCanvas.width = 3072; // Increased from 2048
          textureCanvas.height = 10240; // Increased from 8192

          const texture = new THREE.CanvasTexture(textureCanvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy()); // Increased anisotropy

          const parentMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
          });

          const parentMesh = new THREE.Mesh(parentGeometry, parentMaterial);
          parentMesh.position.set(0, 0, 0);
          parentMesh.rotation.x = THREE.MathUtils.degToRad(-20);
          parentMesh.rotation.y = THREE.MathUtils.degToRad(20);
          scene.add(parentMesh);

          // ADJUSTED CAMERA: Moved back to accommodate larger display
          const distance = 20; // Increased from 30
          const heightOffset = 7;
          const offsetX = distance * Math.sin(THREE.MathUtils.degToRad(20));
          const offsetZ = distance * Math.cos(THREE.MathUtils.degToRad(20));

          camera.position.set(offsetX, heightOffset, offsetZ);
          camera.lookAt(0, -2, 0);
          camera.rotation.z = THREE.MathUtils.degToRad(-5);

          function updateTexture(offset = 0) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

            const fontSize = 220; // Increased font size for titles
            ctx.font = `500 ${fontSize}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const extraSlides = 2;

            for (let i = -extraSlides; i < totalSlides + extraSlides; i++) {
              let slideY = -i * (slideHeight + gap);
              slideY += offset * cycleHeight;

              const textureY = (slideY / cycleHeight) * textureCanvas.height;
              let wrappedY = textureY % textureCanvas.height;
              if (wrappedY < 0) wrappedY += textureCanvas.height;

              let slideIndex = ((-i % totalSlides) + totalSlides) % totalSlides;
              let slideNumber = slideIndex + 1;

              // LARGER SLIDE DIMENSIONS: Increased width and improved spacing
              const slideRect = {
                x: textureCanvas.width * 0.025, // Reduced margins even more (2.5% vs 5%)
                y: wrappedY,
                width: textureCanvas.width * 0.95, // Increased to 95% of texture width
                height: (slideHeight / cycleHeight) * textureCanvas.height,
              };

              const img = images[slideNumber - 1];
              if (img) {
                // ENHANCED ASPECT RATIO: Wider portrait format
                const portraitAspect = 0.8; // Increased from 0.7 for slightly wider images
                
                let drawWidth, drawHeight, drawX, drawY;
                
                // Always fit to height and calculate width based on portrait aspect
                drawHeight = slideRect.height;
                drawWidth = drawHeight * portraitAspect;
                drawX = slideRect.x + (slideRect.width - drawWidth) / 2;
                drawY = slideRect.y;

                ctx.save();
                ctx.beginPath();
                
                // Use correct roundRect API based on browser support
                if (ctx.roundRect) {
                  ctx.roundRect(
                    slideRect.x,
                    slideRect.y,
                    slideRect.width,
                    slideRect.height,
                    40 // Increased corner radius for more modern look
                  );
                } else {
                  // Fallback for browsers without roundRect
                  const radius = 40; // Increased corner radius
                  ctx.moveTo(slideRect.x + radius, slideRect.y);
                  ctx.lineTo(slideRect.x + slideRect.width - radius, slideRect.y);
                  ctx.arcTo(slideRect.x + slideRect.width, slideRect.y, slideRect.x + slideRect.width, slideRect.y + radius, radius);
                  ctx.lineTo(slideRect.x + slideRect.width, slideRect.y + slideRect.height - radius);
                  ctx.arcTo(slideRect.x + slideRect.width, slideRect.y + slideRect.height, slideRect.x + slideRect.width - radius, slideRect.y + slideRect.height, radius);
                  ctx.lineTo(slideRect.x + radius, slideRect.y + slideRect.height);
                  ctx.arcTo(slideRect.x, slideRect.y + slideRect.height, slideRect.x, slideRect.y + slideRect.height - radius, radius);
                  ctx.lineTo(slideRect.x, slideRect.y + radius);
                  ctx.arcTo(slideRect.x, slideRect.y, slideRect.x + radius, slideRect.y, radius);
                }
                
                ctx.clip();
                // Draw image with enhanced portrait aspect ratio
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                ctx.restore();

                // Add text shadow for better readability
                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Reset shadow
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
              }
            }

            texture.needsUpdate = true;
          }

          let currentScroll = 0;
          lenis.on("scroll", ({ scroll, limit, velocity, direction, progress }) => {
            currentScroll = scroll / limit;
            updateTexture(-currentScroll);
            renderer.render(scene, camera);
          });

          // Add a resize handler with proper debouncing
          let resizeTimeout;
          window.addEventListener("resize", () => {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
              renderer.render(scene, camera);
            }, 250);
          });

          // Initial render
          updateTexture(0);
          renderer.render(scene, camera);
          
          // Add animation loop for smoother rendering
          function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
          }
          animate();
        }

        loadImages();
      });
    </script>
  </body>
</html>